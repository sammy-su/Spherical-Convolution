
import os
import sys
import argparse
import cv2
import h5py
import numpy as np

SphConv_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(SphConv_ROOT)

import cfg
import caffe

from cfg import DATA_ROOT
from SphereProjection import SphereProjection
from VOC.VOCData import load_bboxes, IMG_SPHEREH
from util.network import load_network, forward_patch
from util.rf import kernel_sizes
from util.data_io import Logger

LOG_ROOT = os.path.join(SphConv_ROOT, "Log/gen_srcs")
if not os.path.isdir(LOG_ROOT):
    os.makedirs(LOG_ROOT)

def generate_source(path, tilt, **kwargs):
    sphereH = kwargs.get('sphereH', 320)
    sphereW = sphereH * 2
    ks = kwargs.get('ks', 640)
    rf_size = kwargs.get('rf_size', 224)

    dirs, frame = os.path.split(path)
    dirs = dirs.split("/")
    src_dir = os.path.join(DATA_ROOT, "Pano",
                           "Rf{}".format(rf_size),
                           dirs[-2],
                           "tilt{:03d}".format(tilt))
    if not os.path.isdir(src_dir):
        os.makedirs(src_dir)
    frameId = os.path.splitext(frame)[0]
    src_path = os.path.join(src_dir, "{}.h5".format(frameId))
    if os.path.exists(src_path):
        sys.stderr.write("{} exists.\n".format(src_path))
        return
    lockfile = "{}.lock".format(src_path)
    if os.path.isfile(lockfile):
        sys.stderr.write("{} is being generated by other process.\n".format(src_path))
        return
    open(lockfile, "a").close()

    log_dir = os.path.join(LOG_ROOT, "Pano",
                           "Rf{}".format(rf_size),
                           dirs[-2],
                           "tilt{:03d}".format(tilt))
    if not os.path.isdir(log_dir):
        os.makedirs(log_dir)
    log_path = os.path.join(log_dir, "{}.log".format(frameId))
    log = Logger(log_path)
    log.write("Generate output {}\n".format(src_path))

    # prepare projection matrix and network
    layer = "1_1"
    net = load_network(layer=layer, network='faster-rcnn')
    kernel_size = kernel_sizes[layer]
    projection = SphereProjection(kernel_size=kernel_size,
                                  sphereW=sphereW,
                                  sphereH=sphereH,
                                  imgW=ks)

    # Assume convolutional layer
    layer_name = 'conv{}'.format(layer)
    Nch = net.params[layer_name][0].data.shape[0]
    src = np.zeros((sphereH, sphereW, Nch), dtype=np.float32)

    log.write("Start computing convolution.\n")
    img = cv2.imread(path)
    if sphereH != img.shape[0]:
        img = cv2.resize(img, (sphereW, sphereH))
    for y in xrange(sphereH):
        P = projection.buildP(y)
        log.write("Process the {:>3d}-th row\n".format(y))
        log.flush()
        for x in xrange(sphereW):
            rimg = np.roll(img, projection.sphereW/2-x, axis=1)
            patch = projection.project(P, rimg)
            val = forward_patch(patch, net, layer=layer)
            assert val.shape[2] == 1
            assert val.shape[3] == 1
            src[y,x,:] = val.ravel()

    log.write("Write output to disk.\n")
    with h5py.File(src_path, 'w') as hf:
        hf.create_dataset(frameId, data=src,
                          compression="lzf",
                          shuffle=True,
                          chunks=(128, 128, Nch))
    os.remove(lockfile)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--sphereH', type=int, default=320)
    parser.add_argument('--ks', type=int, default=640)
    parser.add_argument('--rf', type=int, default=224)
    parser.add_argument('--frameId', type=str, default=None)
    parser.add_argument('voc', type=int, choices=[2007, 2012], default=2007)
    parser.add_argument('tilt', type=int, default=320)
    parser.add_argument('frame', type=int, default=0)
    args = parser.parse_args()

    kwargs = {
        "sphereH": args.sphereH,
        "view_angle": 65.5,
        "ks": args.ks,
        "rf_size": args.rf,
    }
    orig_tilt = args.tilt * IMG_SPHEREH / args.sphereH
    paths, _, _ = load_bboxes(orig_tilt, args.voc, **kwargs)
    if len(paths) == 0:
        sys.stderr.write("No projected image found.\n")
        return
    n_tasks = len(paths)

    if args.frameId is not None:
        for path in paths:
            if args.frameId in path:
                break
    else:
        if not n_tasks > args.frame >= 0:
            return
        path = paths[args.frame]
    print path
    generate_source(path, args.tilt, **kwargs)

if __name__ == "__main__":
    main()
