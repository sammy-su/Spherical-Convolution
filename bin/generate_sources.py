
import os
import sys
import argparse
import cv2
import h5py
import numpy as np

SphConv_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(SphConv_ROOT)

import cfg
import caffe

from cfg import DATA_ROOT
from SphereProjection import SphereProjection
from util.data_io import collect_frames, get_frameId, Logger
from util.network import load_network
from util.rf import kernel_sizes

LOG_ROOT = os.path.join(SphConv_ROOT, "Log/gen_srcs")
if not os.path.isdir(LOG_ROOT):
    os.makedirs(LOG_ROOT)

def generate_source(frame, layer, sphereH=320, ks=640, network='faster-rcnn'):
    # collect frame information
    frames = collect_frames()
    frame_path = frames[frame]
    frameId = get_frameId(frame_path)

    # Prepare path / check existing file
    kernel_size = kernel_sizes[layer]
    if kernel_size > ks:
        sys.stder.write("Image size should be larger than receptive field.")
        sys.stder.write("Ks: {0} -> {1}\n".format(ks, kernel_size))
        ks = kernel_size

    src_dir = os.path.join(DATA_ROOT,
                           "SourceSphereH{0}Ks{1}".format(sphereH, ks),
                           "{0}{1}".format(network, layer))
    if not os.path.isdir(src_dir):
        os.makedirs(src_dir)
    src_path = os.path.join(src_dir, "{}.h5".format(frameId))
    if os.path.exists(src_path):
        sys.stderr.write("{} exists.\n".format(src_path))
        return
    lockfile = "{}.lock".format(src_path)
    if os.path.isfile(lockfile):
        sys.stderr.write("{} is being generated by other process.\n".format(src_path))
        return
    open(lockfile, "a").close()

    log_dir = os.path.join(LOG_ROOT, "SphereH{0}".format(sphereH),
                           "{0}{1}".format(network, layer))
    if not os.path.isdir(log_dir):
        os.makedirs(log_dir)
    log_path = os.path.join(log_dir, "{}.log".format(frameId))
    log = Logger(log_path)
    batch_size = 128

    # load network
    net = load_network(layer=layer, network=network)
    in_shape = net.blobs['data'].shape
    net.blobs['data'].reshape(batch_size, in_shape[1], in_shape[2], in_shape[3])
    net.reshape()

    # prepare projection matrix
    sphereW = sphereH * 2
    projection = SphereProjection(kernel_size=kernel_size,
                                  sphereW=sphereW,
                                  sphereH=sphereH,
                                  imgW=ks)

    # Assume convolutional layer
    layer_name = 'conv{}'.format(layer)
    Nch = net.params[layer_name][0].data.shape[0]
    src = np.zeros((sphereH, sphereW, Nch), dtype=np.float32)

    log.write("Start computing convolution.\n")
    img = cv2.imread(frame_path)
    if sphereH != img.shape[0]:
        img = cv2.resize(img, (sphereW, sphereH))
    for y in xrange(sphereH):
        P = projection.buildP(y)
        log.write("Process the {:>3d}-th row\n".format(y))
        log.flush()

        for x_start in xrange(0, sphereW, batch_size):
            for i in xrange(batch_size):
                x = x_start + i
                rimg = np.roll(img, projection.sphereW/2-x, axis=1)
                patch = projection.project(P, rimg)
                patch = patch - np.array([103.939, 116.779, 123.68])
                patch = np.transpose(patch, (2,0,1))
                net.blobs['data'].data[i,...] = patch
            target = 'conv{}'.format(layer)
            out = net.forward(blobs=[target])
            vals = out[target].copy()
            assert vals.shape[2] == 1
            assert vals.shape[3] == 1
            for i in xrange(batch_size):
                x = x_start + i
                src[y,x,:] = vals[i].ravel()

    log.write("Write output to disk.\n")
    with h5py.File(src_path, 'w') as hf:
        hf.create_dataset(frameId, data=src,
                          compression="lzf",
                          shuffle=True,
                          chunks=(128, 128, Nch))
    os.remove(lockfile)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--sphereH', dest='sphereH', type=int, default=320)
    parser.add_argument('--ks', dest='ks', type=int, default=640)
    parser.add_argument('--network', dest='network',
                        choices=['vgg16', 'faster-rcnn'], default='faster-rcnn', type=str)
    parser.add_argument('layer', choices=kernel_sizes.keys(), type=str)
    parser.add_argument('frame', type=int)
    args = parser.parse_args()

    generate_source(args.frame, args.layer, sphereH=args.sphereH, ks=args.ks, network=args.network)

if __name__ == "__main__":
    main()
